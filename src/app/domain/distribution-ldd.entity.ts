import {DatabaseService} from '../services/core/database.service';

export abstract class Repository<T extends Entity> {
    private databaseServiceSuper: DatabaseService;

    protected constructor(databaseService: DatabaseService) {
        this.databaseServiceSuper = databaseService;
    }

    createTable(a: T): Promise<any> {
        return this.databaseServiceSuper.executeSql(a.getSqlCreate());
    }
}

export enum SQLiteType {
    INTEGER = 'INTEGER',
    TEXT = 'TEXT',
    NONE = 'NONE',
    REAL = 'REAL',
    NUMERIC = 'NUMERIC'
}

export class ColumnDefinition {
    name: string;
    type: SQLiteType;
    primary?: boolean;
    length?: number;
    comment?: string;
    autoGenerated?: boolean;
    notNull?: boolean;
    unique?: boolean;
}

export function Column(columnDefinition: ColumnDefinition): any {
    return (target, key, descriptor) => {

        if (!(target instanceof Entity)) {
            console.error('Le descripteur @Column ne peut s\'appliquer que sur une classe étendant la classe abstraite Entity');
        }

        // Recherche ou création d'une propriété `columns` dans le prototype de la classe
        const accessor = `columns`;
        if (!target[accessor]) {
            target[accessor] = new Map<string, ColumnDefinition>();
        }
        const columnsMap: Map<string, ColumnDefinition> = target[accessor];

        // Ajout dans la map de la nouvelle ColumnDefinition
        columnsMap.set(key, columnDefinition);
    };
}

export abstract class Entity {
    protected tableName: string;

    protected constructor(tableName: string) {
        this.tableName = tableName;
    }

    getTableName(): string {
        return this.tableName;
    }

    getSqlInsertInto(): string {
        const columns: Map<string, ColumnDefinition> = Object.getPrototypeOf(this).columns;

        let sqlInsert: string = 'INSERT INTO ' + this.getTableName() + ' (';
        for (const entry of columns.entries()) {
            const key = entry[0];
            const value: ColumnDefinition = entry[1];
            sqlInsert += value.name + ', ';
        }
        sqlInsert = sqlInsert.substring(0, sqlInsert.length - 2);

        sqlInsert += ') VALUES (';
        for (const entry of columns.entries()) {
            const key = entry[0];
            const value: ColumnDefinition = entry[1];
            sqlInsert += (value.type === SQLiteType.TEXT) ? '\'' + this[key] + '\'' : this[key];
            sqlInsert += ', ';
        }
        sqlInsert = sqlInsert.substring(0, sqlInsert.length - 2);
        sqlInsert += ');';

        return sqlInsert;
    }

    // TODO finir cette méthode
    getSqlUpdate(): string {
        const columns: Map<string, ColumnDefinition> = Object.getPrototypeOf(this).columns;

        let sqlUpdate: string = 'UPDATE ' + this.getTableName();
        sqlUpdate += ' SET ';
        return sqlUpdate;
    }

    getSqlCreate(): string {
        const columns: Map<string, ColumnDefinition> = Object.getPrototypeOf(this).columns;
        let requestToCreate = 'CREATE TABLE ' + this.getTableName() + ' (';
        for (const entry of columns.entries()) {
            const value: ColumnDefinition = entry[1];
            requestToCreate += value.name + ' ' + value.type;
            requestToCreate += (value.primary) ? ' PRIMARY KEY' : '';
            requestToCreate += (value.autoGenerated) ? ' AUTOINCREMENT' : '';
            requestToCreate += (value.notNull) ? ' NOT NULL' : '';
            requestToCreate += (value.unique) ? ' UNIQUE' : '';
            requestToCreate += ', ';
        }
        requestToCreate = requestToCreate.substring(0, requestToCreate.length - 2);
        requestToCreate += ');';
        return requestToCreate;
    }
}

export enum TypeDistribution {
    DISTRIBUTION = 'DISTRIBUTION',
    NON_DISTRIBUTION = 'NON_DISTRIBUTION'
}

export class DistributionLddEntity extends Entity {
    public static TABLE_NAME = 'element_ldd';

    @Column({name: 'id', type: SQLiteType.INTEGER, comment: 'Id de la LDD', primary: true, autoGenerated: true})
    id: number;

    @Column({
        name: 'date_creation',
        type: SQLiteType.TEXT,
        comment: 'Date de la création au format YYYY-MM-DD HH:MM:SS.SSS'
    })
    dateCreation: string;

    @Column({
        name: 'date_distribution',
        type: SQLiteType.TEXT,
        comment: 'Date de distribution au format YYYY-MM-DD HH:MM:SS.SSS'
    })
    dateDistribution: string;

    @Column({name: 'ldd', type: SQLiteType.INTEGER, comment: 'Id de la LDD'})
    ldd: number;

    @Column({
        name: 'code_barre',
        type: SQLiteType.TEXT,
        length: 13,
        comment: 'Code à barre de l\'objet',
        notNull: true
    })
    codeBarre: string;

    @Column({name: 'statut', type: SQLiteType.TEXT, comment: 'Statut général de la distribution'})
    statut: string;

    @Column({name: 'synced', type: SQLiteType.TEXT, length: 1, comment: 'O/N si la synchronisation a été faite'})
    synced: string;

    @Column({
        name: 'path_signature',
        type: SQLiteType.TEXT,
        comment: 'Path local du device pour l\'image de la signature'
    })
    pathSignature: string;

    @Column({
        name: 'type_description',
        type: SQLiteType.TEXT,
        length: 25,
        comment: 'DISTRIBUTION ou NON_DISTRIBUTION'
    })
    typeDistribution: TypeDistribution;

    constructor() {
        super(DistributionLddEntity.TABLE_NAME);
    }
}
